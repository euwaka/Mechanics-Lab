/*
 * authors: Artur Topal (s5942128) + Lukas Chudy (s5732816)
 * date: 27/02/2025
 *
 * This header contains the structures and functions for handling the routing of IPv4
 * addresses via the router. This file uses an array approach, which is not optimal.
 *
 * All the functions and macros use prefix R_ or r_ that stands for "routes."
 */

#ifndef ROUTER_H
#define ROUTER_H

#include <stddef.h>
#include <stdint.h>

#define R_NUMBER_OCTETS_IPV4 4

typedef uint8_t u8;

/*
 * Type to store an IP address in the IPv4 format. Indexing starts from the left-most
 * octet of the IP. For instance, "192.88.50.2" is indexed as 0: 192, 1: 88, 2: 50, 3: 2.
 */
typedef u8 IPv4_t[R_NUMBER_OCTETS_IPV4];

/*
 * The subnet structure which holds the IP address of the subnet (the network and the
 * host parts), and the subnet mask which tells the number of bits in the IP address
 * corresponding to the network part.
 */
typedef struct {
    IPv4_t ip;
    u8 mask;
} subnet_t;

/*
 * This function takes a terminated string representation of a subnet, creates and
 * returns the corresponding subnet_t structure.
 * Assumption: Themis tests formats IP's and subnets correctly.
 */
subnet_t r_convertStringSubnet(char *buf, size_t len);

/*
 * This function takes a terminated string representation of an IP address, creates and
 * sets the corresponding IPv4_t.
 * Assumption: Themis tests formats IP's correctly.
 */
void r_convertStringIPv4(char *buf, size_t len, IPv4_t *ip);

/*
 * The routing table that stores all the subnets and corresponding interfaces in a router
 * using dynamic arrays.
 */
typedef struct {
    subnet_t *subnets;
    u8  *interfaces;
    unsigned capacity;
    unsigned size;
} routes_t;

/* Displays the routing table (for debug) */
void r_printRoutes(const routes_t routes);

/* Creates an empty routing table with the provided capacity. */
routes_t r_newRoutingTable(unsigned capacity);

/* Adds a subnet and an interface to the routing table. */
void r_addRoute(routes_t *routes, subnet_t subnet, u8 interface);

/* Frees any dynamically allocated memory in routes_t */
void r_freeRoutes(routes_t routes);

/*
 * This function returns the interface that the packet with
 * the given IP destination will end up in after the router
 * perform bitwise LPM with its routings table.
 *
 * Note: this function uses naive LPM algorithm using arrays.
 * The time complexity is O(nk).
 */
u8 r_routeIP(const routes_t routes, const IPv4_t dest);

#endif // ROUTER_H
